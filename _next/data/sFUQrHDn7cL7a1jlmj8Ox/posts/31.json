{"pageProps":{"postData":{"id":"31","title":"介绍一下我的博客架构","tags":["nextjs"],"date":"2022-12-31","image":"/boboan.github.io/posts/31/3.png","abstract":"博客应用最主要的功能就是文章功能，如何写/存文章是博客的核心","contentHtml":"<h2>技术栈</h2>\n<ul>\n<li>nextjs</li>\n<li>react+materialui</li>\n<li>nodejs</li>\n</ul>\n<h2>文章</h2>\n<p>博客应用最主要的功能就是文章功能，如何写/存文章是博客的核心</p>\n<h3>文章存储</h3>\n<p>我的博客使用了服务端生成(SSG)的方式生成html，因为文章数据不会经常改变，所以可以选择ssg生成带有文章数据标签的html，配合编辑/归档功能，实现 <strong>编辑</strong>-><strong>归档</strong>-><strong>生成</strong>-><strong>部署</strong> 这一条线路。文章其实被存储到了html中。这样的好处是不需要数据库存储文章，并且首次请求的html文档中有文章数据，对搜索引擎很友好，一次get请求就可以拿到所有文章数据。</p>\n<h3>文章编辑</h3>\n<p>我没有在webapp中做富文本编辑的功能，我是用的是简书的文章编辑的功能。是用简书可以方便的上传图片，并保存写好的markdown，是用简书编辑好了之后，粘贴到我项目本地的md文件中，再调用归档的代码生成文章的json数据并保存文章中的图片。\n这里借用了简书的图片上传，和文章存储的功能，借用其他的第三方应用也是可以的~</p>\n<h3>markdown 解析</h3>\n<ul>\n<li>remark 库\n我是用的是 NextJs 一个<a href=\"https://github.com/vercel/next.js/tree/canary/examples/blog-starter\">示例项目</a>中推荐的 markdown 解析的库<code>npm install remark remark-html -D</code></li>\n<li>handlers\n这块我没有看到有文档，不过可以从他源码中看到 handler 函数 <a href=\"https://github1s.com/syntax-tree/mdast-util-to-hast/blob/HEAD/lib/handlers/image.js\">image</a></li>\n</ul>\n<ol>\n<li>img tag 下载图片\n我需要把简书的图片资源下载到本地，所以在语法转换过程中，写了一个 image handler。</li>\n<li>pre code tag 代码块\n代码块的样式我是用的是 <a href=\"https://prismjs.com/\">prismjs</a> 大概就是长这样 ↓\n<img src=\"/boboan.github.io/posts/31/1.png\">\n值得注意的是 remark-html 这个库，在生成 tag 字符串时，有一个 property 清洗的过程，他会将 pre 标签上 prismjs 依赖的 className 删除掉，因为 remark-html 默认认为 pre 标签不应该有 class 属性。\n可以看我这个文章，给他提供额外的 schema，或者直接传 false 选择不清洗 property\n<a href=\"https://www.jianshu.com/p/e5c7a303d49a\">remark md转html丢class的问题</a></li>\n</ol>\n<h3>文章归档</h3>\n<p>以前我并不明白文章归档功能是做什么用的，但我这次写博客代码的时候发现，这个架构下，真的很需要归档功能。\n<img src=\"/boboan.github.io/posts/31/2.png\"></p>\n<p>我创建了2个文件夹，tofile 是待归档目录存放需要创建和修改的文章；file 是已归档，存放已经完成转换的 json 数据和原始 md 文件</p>\n<h4>归档成json</h4>\n<p><strong>在需要的时候解析md，而不是每次ssg时</strong>\n我博客文章的来源是简书，我会从简书粘 MD 到我博客项目中。不过如果每次在 nextjs ssg 过程中都去解析一遍 md ，这样当文章多了之后 ssg 过程会很慢，因为当文章没有修改时，按照 next 示例项目的 ssg 过程也会解析 md 文档。所以我选择写一个<strong>归档功能</strong>在文章修改之后执行一下归档代码，把 markdown 归档成 json 和 image 图片。这样每次 ssg 的过程只需要读取 json 文件提供给 <code>getStaticProps</code> 函数就可以了</p>\n<h4>下载image</h4>\n<p>然后我的 markdown 数据中的图片资源，是通过第三方比如说简书的富文本编辑器的图片上传功能存到 md 中的，所以不太好用人家的文件地址，所以我在归档过程中，从简书的文件服务上下载到我本地了。\n在解析 md 语法时，可以给<code>remark-html</code> 传一个 handlers 参数，作为 img 标签的处理函数，我在这里同步的把简书 url 转换成了本地 url，并且进行了异步下载保存到约定的位置。</p>\n<pre><code class=\"language-typescript\">const processedContent = await remark()\n        .use(html, {\n            sanitize: false,\n            handlers: {\n                image: (h, node) => {\n                    // 下载图片\n                    const fileName = `${index++}${readExt(node.url)}`\n                    downloadImage(node.url).then(f => {\n                        // 检查目录\n                        const dir = checkImgDir(id)\n                        // 保存图片\n                        fs.writeFileSync(path.resolve(dir, fileName), f)\n                    })\n                    return h(node, 'img', { src: `/posts/${id}/${fileName}` })\n                }\n            }\n        })\n        .process(matterResult.content)\n</code></pre>\n<h2>NextJS SSG</h2>\n<p><a href=\"https://nextjs.frontendx.cn/docs/#%E5%AF%BC%E5%87%BA%E9%9D%99%E6%80%81%E9%A1%B5%E9%9D%A2\">导出静态页面</a>\n这块我看文档没有讲清楚。可以参考 next 博客的 example ，这里简单介绍一下以下三个要素</p>\n<h3>getStaticPaths</h3>\n<p>getStaticPaths 函数是当你的 Next 路由是 [id].tsx 这样的文件路由时，你需要用 getStaticPaths 函数，告诉 nextjs id 都有哪些值</p>\n<pre><code class=\"language-typescript\">export async function getStaticPaths() {\n  return {\n    paths: getAllIds().map((id) => ({\n      params: { id },\n    })),\n    fallback: false,\n  };\n}\n</code></pre>\n<h3>getStaticProps</h3>\n<p>getStaticProps 函数是 next 在服务端渲染时，页面组件的初始 props 值。好让 next 在服务端渲染时，知道初始数据是怎样的</p>\n<pre><code class=\"language-typescript\">export function getStaticProps({ params: { id } }: any) {\n  return {\n    props: {\n      postData: getPost(id),\n      allTags: getAllTags(),\n    },\n  };\n}\n</code></pre>\n<h3>next build &#x26;&#x26; next export</h3>\n<p>当你的所有页面都按照要求写好服务端的生成数据的函数时，执行<code>next build &#x26;&#x26; next export</code> 开始 ssg 构建</p>\n<h2>网站部署</h2>\n<h3>github pages / vercel</h3>\n<p>这两个都是提供免费的部署服务，我先用了 github page\n<a href=\"https://www.jianshu.com/p/e31095941aeb\">使用GitHub Page部署静态页面</a></p>\n<h3>部署脚本</h3>\n<p>将 export 出来的 out 目录 push 到 github page 对应的仓库中就可以完成部署</p>\n<pre><code class=\"language-javascript\">const exec = require('child_process').execSync\nconst path = require('path')\n\nfunction main() {\n    const gitOption = { cwd: path.resolve(__dirname, '../out') }\n    exec('git init -q', gitOption)\n    exec('git remote add origin https://github.com/ranmeizi/boboan.github.io.git', gitOption)\n    exec('git add --all', gitOption)\n    exec(`git commit -m 'AutoPublish'`, gitOption)\n    exec('git push origin master -f', gitOption)\n}\nmain()\n</code></pre>\n<hr class=\"MuiDivider-root\">\n<p>这样下来，写文章，归档，部署一套就完成了一个博客应用</p>\n<p><a href=\"https://ranmeizi.github.io/boboan.github.io/\">https://ranmeizi.github.io/boboan.github.io/</a>\n<img src=\"/boboan.github.io/posts/31/3.png\"></p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}