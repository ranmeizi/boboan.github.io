{"pageProps":{"postData":{"id":"17","title":"[screeps]room孵化队列的设计","tags":["screeps"],"date":"2021-02-28","image":"/boboan.github.io/posts/17/1.png","abstract":"在房间Coltroller等级达到7级和8级的时候，每个房间将解锁第二个/第三个Spawn，这时候就要考虑代码怎么能**多兵营(spawn)**同时造兵，而不是让spawn成为一个巨大的Extension","contentHtml":"<p>在房间Coltroller等级达到7级和8级的时候，每个房间将解锁第二个/第三个Spawn，这时候就要考虑代码怎么能**多兵营(spawn)**同时造兵，而不是让spawn成为一个巨大的Extension</p>\n<p><img src=\"/boboan.github.io/posts/17/1.png\"></p>\n<h2>孵化任务列表</h2>\n<p>设想有一个孵化任务列表，来让spawn们自己来认领自己的孵化任务，当spawn可以孵化时，那我就领下这个任务。当spawn正在孵化时，那就不领。\n现在要考虑的问题就是:</p>\n<ol>\n<li>生成孵化任务列表</li>\n<li>spawn认领任务</li>\n</ol>\n<h2>生成孵化任务列表</h2>\n<p>在教程中，教给我们的是，使用数量来判断是否需要孵化更多的role，我也没有研究出更好的方法，也是用数量判断。\n设定一个limit值表示房间内规划的数量，例如<code>limit = 2</code>,那当我在房间内数creep数小于limit值时，就要向孵化列表中push孵化任务了。\n接下来的问题时那这个房间内数量的值，怎么获取呢？\n使用memory存储，在孵化creep时除了<code>role</code>还定义了1个额外的值<code>room</code> 来标识这个creep出生的房间。\n循环<code>Game.creeps</code>时,就能从memory中获得各个room中的role数量了\n但这样还不够，有可能出现这种情况无法完成全部孵化任务\n1.energy不够，spawn无法完成孵化任务\n2.spawn在孵化中无法完成孵化任务\n那在本tick结束后，队列中的指标还是没有完成，下一tick就会继续push孵化任务。\n所以在计算数量的时候，还要算上queue中预孵化的这一部分creep</p>\n<h2>spawn认领任务</h2>\n<p>在创建好孵化任务列表后，认领任务就简单多了，只要循环<code>Game.spawns</code>判断spawnCreep的返回值，如果成功，那就删除第一个任务就好了。\n有一点要注意的是，教程里为creep命名时，用的时Game.time，但实际上，有可能是同一tick时多个spawn一起孵化，而creep的名字不能重复，就要给creep一个绝对不能重复的名字。\n我翻了下lodash文档，还真有<code>_.uniqueId([prefix=''])</code>\n<img src=\"/boboan.github.io/posts/17/2.png\"></p>\n<p>这样设计，spawn孵化资源就能利用上了，附几个代码参考</p>\n<ul>\n<li>数量检测Env.js</li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = function () {\n  // 清除死去creep的memory\n  const creepsName = Object.keys(Game.creeps)\n  Object.keys(Memory.creeps).forEach(name => {\n    if (!creepsName.includes(name)) {\n      delete Memory.creeps[name]\n    }\n  })\n  // 统计每个房间creeps数\n  global.roomCreeps = {}\n  Object.values(Game.creeps).forEach(creep => {\n    const { room, role } = creep.memory\n    if (!global.roomCreeps[room]) {\n      global.roomCreeps[room] = {\n        [role]: 1\n      }\n    } else if (!global.roomCreeps[room][role]) {\n      global.roomCreeps[room][role] = 1\n    } else {\n      global.roomCreeps[room][role]++\n    }\n  })\n}\n</code></pre>\n<ul>\n<li>room控制器</li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = function (room) {\n  roomSpawnCreeps(room)\n}\n\n/**\n * 检查creep数量 room数+queue数\n */\nfunction roomSpawnCreeps(room) {\n  const { harvester = 0 } = global.roomCreeps[room.name] || {}\n  const queue = room.memory.queue || []\n  const queueNum = {}\n\n  queue.forEach(role => {\n    queueNum[role]\n      ? queueNum[role]++\n      : queueNum[role] = 1\n  })\n\n  if (harvester + (queueNum['harvester'] || 0) &#x3C; 2) {\n    queue.push('harvester')\n  }\n  room.memory.queue = queue\n}\n</code></pre>\n<ul>\n<li>spawn控制器</li>\n</ul>\n<pre><code class=\"language-javascript\">module.exports = function (spawn) {\n  getSpawnFromQueue(spawn)\n}\n\n// 从队列种选取孵化任务，领取后，shift掉\nfunction getSpawnFromQueue(spawn) {\n  const queue = spawn.room.memory.queue\n  // 是否可以孵化？\n  if (queue.length > 0 &#x26;&#x26; !spawn.spawning) {\n    const role = queue[0] // 孵化队列第一位\n    const bodys = getBodys(role)\n    const result = bodys &#x26;&#x26; spawn.spawnCreep(bodys, _.uniqueId('harvester_'), {\n      memory: {\n        role: 'harvester',\n        room: spawn.room.name\n      }\n    })\n    if (result === OK) {\n      queue.shift()\n      spawn.room.memory.queue = queue\n    }\n  }\n}\n\nfunction getBodys(role) {\n  if (role === 'harvester') {\n    return [WORK, MOVE, CARRY]\n  }\n}\n</code></pre>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}