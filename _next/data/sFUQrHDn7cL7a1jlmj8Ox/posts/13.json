{"pageProps":{"postData":{"id":"13","title":"正六边形棋盘的思路","tags":["闲的","canvas"],"date":"2020-11-07","image":"/boboan.github.io/posts/13/1.png","abstract":"这是一个正六边形的棋盘，里面的格子都是由正三角形组成的 棋子也是由正三角形组成的，棋子要落在棋盘上，就要知道棋子的位置 研究的问题是，怎么去描述棋子的位置 经过数学大神点播后，有了一点想法，分享一个思路","contentHtml":"<p><img src=\"/boboan.github.io/posts/13/1.png\">\n这是一个正六边形的棋盘，里面的格子都是由正三角形组成的\n棋子也是由正三角形组成的，棋子要落在棋盘上，就要知道棋子的位置\n研究的问题是，怎么去描述棋子的位置\n经过数学大神点播后，有了一点想法，分享一个思路</p>\n<h2>化简化简</h2>\n<ol>\n<li>格子编号\n因为棋子和棋盘都是由格子组成的，想了半天，我觉得给格子编号会比较方便</li>\n<li>棋盘分区\n正六边形其实可以看做是6块三角形组成的，在平面直角坐标系中按照原点旋转是有公式的\nx1=cos(angle)*x-sin(angle)*y;\ny1=cos(angle)*y+sin(angle)*x;\n那么这个正六边形，就可以看作由1个三角形旋转不同角度获得的\n给棋盘分为6个区，那么研究的问题就变成了一个正三角形</li>\n<li>建立坐标系\n选了一个自己算着舒服的三角形建立坐标系\n<img src=\"/boboan.github.io/posts/13/2.png\"></li>\n<li>分层编号，寻找规律\n<img src=\"/boboan.github.io/posts/13/3.png\"></li>\n</ol>\n<ul>\n<li>每一层的Y轴坐标相差√3/2</li>\n<li>每个编号的X轴坐标相差1/2</li>\n<li>唯一不同的是编号3是朝上的三角形，而编号1，2，4是朝下的三角形，但是通过分层可以发现，每层<strong>奇数</strong>号的三角形是朝下的，<strong>偶数</strong>号的三角形是朝上的</li>\n<li>而且朝上的三角形与朝下的三角形,他们的Y轴坐标也是加减√3/2，X轴不变（见绿色三角形）</li>\n</ul>\n<h2>代码实现</h2>\n<pre><code class=\"language-javascript\">let baseAreas = 6\nlet baseIds = 81\nconst G3 = Math.sqrt(3)\n// 把所有三角都看作是1,1的三角变换而来,那么保存一个1,1三角的坐标\nconst defaultTri = [\n\t[0, 0],\n\t[1 / 2, G3 / 2],\n\t[-1 / 2, G3 / 2],\n]\n// 根据area和id获取三角形3个顶点坐标\nfunction getVertex(id) {\n\tconst [tier, index] = getTier(id)\n\t// 根据11变换\n\tlet coord = transform(tier, index)\n\t// index如果是偶数,y轴坐标需要变换\n\tif (index % 2 === 0) {\n\t\tcoord = indexTransformY(coord)\n\t}\n\treturn coord\n}\n\n// 根据id获取在area中的层数与该层第几个\nfunction getTier(id) {\n\tconst tier = Math.ceil(Math.sqrt(id))\n\t// 减去上一层的总数\n\tconst index = id - Math.pow(tier - 1, 2)\n\treturn [tier, index]\n}\n\nfunction transform(tier, index) {\n\t// X=(tier-index)*1/2\n\t// y=(tier-1)*G3/2\n\treturn defaultTri.map(([x, y]) => [x + (tier - index) * 1 / 2, y + (tier - 1) * G3 / 2])\n}\n\nfunction indexTransformY([\n\t[x1, y1],\n\t[x2, y2],\n\t[x3, y3]\n]) {\n\treturn [\n\t\t[x1, y1 + G3 / 2],\n\t\t[x2, y2 - G3 / 2],\n\t\t[x3, y3 - G3 / 2],\n\t]\n}\n\n/* \n\t变换的每个area旋转60°\n\tx1=cos(angle)*x-sin(angle)*y;\n\ty1=cos(angle)*y+sin(angle)*x;\n*/\nfunction rotate(area, coord) {\n\tconst arg = (area - 1) * 60 * 2 * Math.PI / 360\n\treturn coord.map(([x, y]) => [\n\t\tMath.cos(arg) * x - Math.sin(arg) * y,\n\t\tMath.cos(arg) * y + Math.sin(arg) * x\n\t])\n}\n</code></pre>\n<ol>\n<li>主方法是<strong>getVertex</strong>和<strong>rotate</strong>，getVertex负责根据编号获取三角形的3个顶点坐标，rotate负责根据分区旋转这个坐标</li>\n<li><strong>getTier</strong>根据编号获取层数</li>\n<li><strong>transform</strong> 根据编号规律(层以及层内编号)获得三角形顶点坐标</li>\n<li><strong>indexTransformY</strong>根据本层编号奇偶去做Y轴变换</li>\n</ol>\n<p>通过拆分成几个小问题就比较清晰拉~去实现每一个小问题的function就可以了</p>\n<h2>验证</h2>\n<p><img src=\"/boboan.github.io/posts/13/4.gif\"></p>\n<p>附上一个比较直观的画图方法</p>\n<pre><code class=\"language-javascript\">// 画图验证\nwindow.onload = function() {\n\tbtn.addEventListener('click', () => {\n\t\t// 获取area\n\t\tlet area = document.getElementById('area').value\n\t\tlet id = document.getElementById('id').value\n\t\ttri = [area, id]\n\t\tdraw()\n\t})\n\tcanvas.addEventListener('mousewheel', ({\n\t\tdeltaY\n\t}) => {\n\t\tif (deltaY &#x3C; 0) {\n\t\t\tzoom = zoom + 2\n\t\t} else {\n\t\t\tzoom = zoom - 2 &#x3C; 0 ? 2 : zoom - 2\n\t\t}\n\t\tdraw()\n\t})\n\tcanvas.addEventListener('mousedown', mouseDown)\n\tdraw()\n}\n\nfunction mouseDown() {\n\twindow.addEventListener('mousemove', mouseMove)\n\twindow.addEventListener('mouseup', mouseUp)\n}\n\nfunction mouseUp() {\n\twindow.removeEventListener('mousemove', mouseMove)\n\twindow.removeEventListener('mouseup', mouseUp)\n}\n\nfunction mouseMove({\n\tmovementX,\n\tmovementY\n}) {\n\torigin[0]=origin[0] + movementX\n\torigin[1]=origin[1] + movementY\n\tdraw()\n}\n\n\nboard = [] // 棋盘\ntri = [] // 三角\n\nfor (let i = 1; i &#x3C;= baseAreas; i++) {\n\tfor (let j = 1; j &#x3C;= baseIds; j++) {\n\t\tboard.push(rotate(i, getVertex(j)))\n\t}\n}\n\nlet zoom = 30\nconst origin = [0, 0]\n\nfunction draw() {\n\tdrawBoard()\n\tdrawTarget()\n}\n\nfunction drawBoard() {\n\t// 画棋盘\n\tconst {\n\t\tclientWidth: width,\n\t\tclientHeight: height\n\t} = canvas\n\n\tlet oX = width / 2\n\tlet oY = height / 2\n\tconst ctx = canvas.getContext('2d')\n\tctx.fillStyle = '#fff';\n\tctx.fillRect(0, 0, width, height)\n\tctx.lineWidth = 1;\n\tctx.strokeStyle = '#000';\n\tconst [dx, dy] = origin\n\tboard.forEach(([\n\t\t[x1, y1],\n\t\t[x2, y2],\n\t\t[x3, y3]\n\t]) => {\n\t\tctx.beginPath()\n\t\t// canvas y轴取反\n\t\ty1 = -y1\n\t\ty2 = -y2\n\t\ty3 = -y3\n\t\tctx.moveTo(x1 * zoom + oX + dx, y1 * zoom + oY + dy)\n\t\tctx.lineTo(x2 * zoom + oX + dx, y2 * zoom + oY + dy)\n\t\tctx.lineTo(x3 * zoom + oX + dx, y3 * zoom + oY + dy)\n\t\tctx.closePath()\n\t\tctx.stroke();\n\t})\n}\n\nfunction drawTarget() {\n\tconst {\n\t\tclientWidth: width,\n\t\tclientHeight: height\n\t} = canvas\n\n\tlet oX = width / 2\n\tlet oY = height / 2\n\tconst ctx = canvas.getContext('2d')\n\n\tconst [dx, dy] = origin\n\tconst [area, id] = tri\n\n\tif (area &#x26;&#x26; id) {\n\t\tlet [\n\t\t\t[x1, y1],\n\t\t\t[x2, y2],\n\t\t\t[x3, y3]\n\t\t] = rotate(area, getVertex(id))\n\t\tctx.lineWidth = 2;\n\t\tctx.strokeStyle = 'red';\n\t\tctx.beginPath()\n\t\t// canvas y轴取反\n\t\ty1 = -y1\n\t\ty2 = -y2\n\t\ty3 = -y3\n\t\tctx.moveTo(x1 * zoom + oX + dx, y1 * zoom + oY + dy)\n\t\tctx.lineTo(x2 * zoom + oX + dx, y2 * zoom + oY + dy)\n\t\tctx.lineTo(x3 * zoom + oX + dx, y3 * zoom + oY + dy)\n\t\tctx.closePath()\n\t\tctx.stroke();\n\t}\n}\n</code></pre>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}