{"pageProps":{"postData":{"id":"12","title":"全局的异步任务队列","tags":["promise"],"date":"2020-10-29","image":"/boboan.github.io/posts/12/1.png","abstract":"举个栗子 当你找到一个免费接口，1分钟限制调用次数10次的时候 当你有一个耗费大量前端资源多个任务同时执行会导致内存溢出的时候","contentHtml":"<p>举个栗子\n当你找到一个免费接口，1分钟限制调用次数10次的时候\n当你有一个耗费大量前端资源多个任务同时执行会导致内存溢出的时候</p>\n<p>大概意思就是我想让这个任务排队执行，或者延迟执行，又不想把逻辑写到组件里\n我想要的是，随时可以把任务插进队列，队列中的任务会等待前一个任务完成再执行，任务完成后callback,还需要一个reject中断任务</p>\n<p>写一个任务队列</p>\n<pre><code class=\"language-javascript\">// 任务队列\nfunction Queue() {\n    this.queue = []\n}\n// 往队列里增加一项任务\nQueue.prototype.append = async function (getWork, callback) {\n    // 判断这是否是队列中的第一项\n    if (this.queue.length === 0) {\n        this.queue.push({ getWork, callback })\n        await this.go()\n    } else {\n        this.queue.push({ getWork, callback })\n    }\n}\nQueue.prototype.go = async function () {\n    if (this.queue.length !== 0) {\n        const { getWork, callback } = this.queue[0]\n        callback(await getWork())\n        this.queue.splice(0, 1)\n        await this.go()\n    }\n}\nQueue.prototype.reject = async function () {\n    this.queue = []\n}\n\n\n// 测试\nlet workQueue = new Queue()\nfor (let i = 1; i &#x3C;= 10; i++) {\n    console.log(`第${i}个任务进入队列,${Date.now()}`)\n    workQueue.append(() => new Promise(resolve => {\n        setTimeout(() => {\n            resolve(i)\n        }, 1000);\n    }), (data) => {\n        console.log(`第${data}个任务执行完成,${Date.now()}`)\n    })\n}\n// setTimeout(() => {\n//     console.log('中断')\n//     workQueue.reject()\n// }, 5000);\n</code></pre>\n<p>测试一下\n<img src=\"/boboan.github.io/posts/12/1.png\">\n测试一下中断\n<img src=\"/boboan.github.io/posts/12/2.png\">\n还是callback 第六次了😂，凑合用把</p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}