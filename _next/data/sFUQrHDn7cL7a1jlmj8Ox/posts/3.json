{"pageProps":{"postData":{"id":"3","title":"[eggjs]异常捕获中间件，一下子理解koa洋葱圈模型","tags":["eggjs"],"date":"2020-04-10","image":"/boboan.github.io/posts/3/1.png","abstract":"开始看 koa 的时候有一个洋葱圈模型的概念，一直没弄明白。直到我在跟着 egg 文档写异常捕获的时候，突然明白了咋回事。","contentHtml":"<p>开始看koa的时候有一个洋葱圈模型的概念，一直没弄明白。直到我在跟着egg文档写异常捕获的时候，突然明白了咋回事。</p>\n<p>egg的文档提有超详细的教程，手把手带你写一个后台服务\n这里：<a href=\"https://eggjs.org/zh-cn/intro/quickstart.html\">https://eggjs.org/zh-cn/intro/quickstart.html</a></p>\n<h2>统一的异常处理</h2>\n<p>在开发服务时，会遇到很多异常和错误，比如数据库报错这种异常，比如密码错误这种业务相关的错误。那当遇到错误时，就不需要执行后面的逻辑，直接响应一个错误给客户端。</p>\n<h3>拿登录接口举个例子</h3>\n<p><img src=\"/boboan.github.io/posts/3/1.jpg\">\n①第一步数据库操作，可能我们需要catch到错误，完后结束掉请求</p>\n<pre><code class=\"language-javascript\">  try{\n    //doSomething   ...你的数据库操作\n  }catch(e){\n      //啊  出错了，进行不下去了\n      this.ctx.status=500\n      this.ctx.body='写点啥'\n  }\n</code></pre>\n<p>②第二步，数据库是健康的，我得拿着Uname去请求User数据了</p>\n<pre><code class=\"language-javascript\">    async getUserByUname(uname){\n          const result = await model.user.getUserByUname(uname)  //执行sql语句\n          //没有数据？那得返回：没有此用户\n          if(result.length===0){\n              //查询不到，更别提密码了\n              this.ctx.body='没有此用户'\n          }\n          //。。。你之后的逻辑\n    }\n</code></pre>\n<p>③第三步，我都不想写了，已经很乱了，每个错误都要在controller文件或者service文件中响应一个错误原因message，找都找不到</p>\n<h3>试试把错误统一管理</h3>\n<pre><code class=\"language-javascript\">//errorHandler中间件\nexport default () => {\n  return async function errorHandler(ctx, next) {\n    try {\n      await next()\n    } catch (err) {\n      const status = err?.status || 500\n      // 不知道是啥的异常记录日志\n      status === 500 &#x26;&#x26; ctx.app.emit('error', err, ctx);\n      const error = status === 500 &#x26;&#x26; ctx.app.config.env === 'prod'\n        ? 'Internal Server Error'\n        : err.message\n      const msg = status > 600 ? CST_ERR_CODE[status] : error\n      ctx.body = await ctx.service.response.format(status || 500, null, msg)\n    }\n  };\n};\n//自定义错误\nexport class CustError extends Error {\n  status: number\n  constructor(status: number, message?: string) {\n    super()\n    this.status = status\n    if (message) {\n      this.message = message\n    }\n  }\n}\n//错误代码\nexport enum CST_ERR_CODE {\n  // 10001-登录-密码错误\n  Login_WrongPass = 10001,\n  // 10002-登录-没有此用户\n  Login_NoUser = 10002,\n  // 10003-登录-验证失败\n  Login_VerificationFail = 10003,\n  // 10004-注册-重复的用户名\n  Regist_SameUname = 10004,\n  // 10005-注册-注册失败\n  Regist_Wrong = 10005\n}\n</code></pre>\n<p>1.使用errorHandler中间件包裹猪我们的代码，在我们的代码抛出异常时，在errorHandler里统一catch错误，并响应错误\n2.自定义的错误对象，在判断出登录错误问题时，直接<code>throw new CustError(CST_ERR_CODE.Login_WrongPass)</code>\n3.定义错误代码</p>\n<h3>洋葱圈模型</h3>\n<p>那为什么我们可以这么干，我想起了我以前看到的洋葱圈模型的图片\n<img src=\"/boboan.github.io/posts/3/2.png\">\n最内部是APP，外面是一层一层的koa中间件，在每个中间件中next()执行内部的代码\n上面解释的是ErrorHandler中间件的作用，当内部洋葱throw出错误时，使用ErrorHandler中间件catch到错误结束掉本次请求\n是不是明白这个大葱头的图片是啥意思了😀</p>\n<p>然后需要注意的是，你这一堆function一定要组成一个async await异步链，才能catch住</p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}