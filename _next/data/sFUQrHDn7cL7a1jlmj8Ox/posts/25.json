{"pageProps":{"postData":{"id":"25","title":"非前端React简单学习(一) javascript","tags":["javascript","react"],"date":"2021-09-29","image":"/boboan.github.io/images/tags/js.jpg","abstract":"web 开发其实是 html/js/css。前端开发们使用 javascript 脚本语言，调用 html 标准的 domapi 渲染dom标签，使用 js 逻辑处理按钮交互逻辑","contentHtml":"<h2>简介</h2>\n<p>web 开发其实是 html/js/css。前端开发们使用 javascript 脚本语言，调用 html 标准的 domapi 渲染dom标签，使用 js 逻辑处理按钮交互逻辑</p>\n<p>随着开发的业务越来越复杂，代码量越来越大，原始的 html / js / css 写出的代码复用困难，可读性低。于是聪明的程序员用新的开发思想编写了 React 框架</p>\n<p>本文介绍了一些知识点帮助非前端的小伙伴们学习react，快速建立起知识体系</p>\n<h2>文档建议</h2>\n<p>比较官方的文档推荐<br>\njs api 索引：https://developer.mozilla.org/zh-CN/<br>\nreact： https://react.docschina.org/tutorial/tutorial.html</p>\n<h2>开发环境搭建</h2>\n<p>现在 web 开发会用到一些打包框架，来创建项目，语法转换，压缩代码，这些打包框架需要使用 nodejs 环境。包括 rn 也是需要 node 12+ 的环境。</p>\n<h3>nvm</h3>\n<blockquote>\n<p>推荐使用 nvm，而不是安装 nodejs<br>\nnvm 是一个 nodejs 版本管理工具，当你需要切换 nodejs 版本时，nvm 是一个很好的工具<br>\nwindows 安装nvm ：https://www.jianshu.com/p/96f9317db0b5<br>\nmac 安装nvm：https://www.jianshu.com/p/622ad36ee020<br>\nmac 注意安装最新版本 nvm，并且 mac m1 芯片 需要使用兼容模式安装</p>\n</blockquote>\n<p>当终端 nvm 命令可以执行，且 node -v 正确显示 nodejs 版本 就算安装成功<br>\n然后使用 nvm install 安装nodejs<br>\n使用nvm list 查看已安装版本<br>\n使用nvm use &#x3C;virsion> 使用对应版本nodejs</p>\n<h3>vscode</h3>\n<blockquote>\n<p>主流ide<br>\nhttps://code.visualstudio.com/</p>\n</blockquote>\n<h2>html js css 学习</h2>\n<p>js</p>\n<ul>\n<li>变量声明</li>\n</ul>\n<pre><code class=\"language-javascript\">    var name = '张三'\n    var age = 18\n    console.log(name)\n    console.log(age)\n</code></pre>\n<ul>\n<li>类型/类型判断</li>\n</ul>\n<p>基础类型：string number boolean null undefined symbol<br>\nnull 会被<code>typeof</code>判断为 object 但他与引用类型是有区别的</p>\n<pre><code class=\"language-javascript\">    // 字符串\n    var name = '张三'\n    console.log(typeof name) // string\n    // 数字\n    var age = 18\n    console.log(typeof age) // number\n    // 布尔\n    var isMan = true\n    console.log(typeof isMan) // boolean\n    // 空对象\n    var girlfriend = null\n    console.log(typeof girlfriend) // null\n    // 未定义\n    var baby\n    console.log(typeof baby) // object\n    // 唯一值\n    var id = Symbol('张三')\n    console.log(typeof id) // symbol\n</code></pre>\n<p>引用类型：object function array 等</p>\n<pre><code class=\"language-javascript\">    // 对象\n    var person = {\n        name: '张三',\n        age: 18,\n        isMan: true,\n        girlfriend: null\n    }\n    // 对象取值 .\n    console.log(person.name)\n    // 对象取值 []\n    console.log(person['name'])\n\n    // 数组 成员可以是任意类型,甚至可以是函数\n    var array = ['张三',18,true,null,function(){}]\n    // 数组取值 [] 下标从0开始\n    console.log(array[0])\n</code></pre>\n<p>从内存来看，基础类型的变量对应着实际的值，而引用类型的变量对应着存储着这些基础类型值的地址，这意味着当你使用=把一个引用类型的值赋给变量时，存储的实际上是地址，并没有生成一个新的对象，而当你使用key访问并修改新变量上的值时，老变量也会受到影响。这时我们就需要深拷贝去创建一个新的对象</p>\n<pre><code class=\"language-javascript\">    var obj1 = {\n        name: '鲤鱼王',\n        level: 19\n    }\n    var obj2 = obj1\n    obj2.level++\n    obj2.name = '暴鲤龙'\n    console.log(obj1, obj2)\n</code></pre>\n<ul>\n<li>深拷贝/浅拷贝</li>\n</ul>\n<p>上面说的，自己百度吧</p>\n<ul>\n<li>函数<br>\n实现功能的代码块<br>\nfuntion 和 箭头函数</li>\n</ul>\n<pre><code class=\"language-javascript\">    function add(num1, num2){\n        return num1 + num2\n    }\n    console.log(add(1,2)) // 3\n\n    const addLambda = (num1, num2) => num1 + num2\n \n    console.log(addLambda(1,2)) // 3\n</code></pre>\n<ul>\n<li>if / switch<br>\n条件分支</li>\n</ul>\n<pre><code class=\"language-javascript\">    var person = {\n        name: '张三',\n        age: 18,\n        isMan: true,\n        girlfriend: null\n    }\n    // if判断\n    if(person.isMan === true){\n        console.log('进入男厕所')\n    }else{\n        console.log('进入女厕所')\n    }\n    // switch\n    switch(person.isMan){\n        case true: console.log('进入男厕所');break;\n        case false: console.log('进入女厕所');break;\n        default: console.log('mei sha yi yi ');break\n    }\n</code></pre>\n<ul>\n<li>循环<br>\nfor 和 while<br>\n这个应该不用讲</li>\n<li>垃圾回收与闭包</li>\n</ul>\n<p>除非你知道闭包是怎么回事，不然躲着点写<br>\njs的垃圾回收机制简单来说就是在变量无论如何也访问不到时，js会将这个变量回收<br>\n例如</p>\n<pre><code class=\"language-javascript\">    // 例如一个函数执行结束之后\n    function fn(){\n        var a = 1\n    }\n    fn()\n    // 例如失去引用\n    var a = {\n        name:'a'\n    }\n    // 这里的‘a’失去了引用\n    a.name=1\n</code></pre>\n<p>不过，一旦A函数返回另一个B函数，在B函数中又引用了A函数作用域中的变量，那么就算A函数运行完这个\bB函数也会一直引用A函数作用域中的变量，造成不回收，形成闭包。可以利用这一特性存储一些数据</p>\n<pre><code class=\"language-javascript\">    function A{\n        var name='A'\n        return function B(){\n            console.log(name)\n        }\n    }\n    // 这里就形成了一个闭包\n    const fnB=A()\n</code></pre>\n<ul>\n<li>类 与 原型 面向对象<br>\n虽然支持 class 语法，但 js 中是的类是用原型链实现的，不建议初学去了解，语法介绍一下</li>\n</ul>\n<pre><code class=\"language-javascript\">    // 单位\n    class Item {\n        // 名称\n        name = ''\n        // 位置\n        pos={\n            x:0,\n            y:0\n        }\n        constructor(name){\n            this.name = name\n        }\n        // 移动\n        moveTo(x,y){\n            this.pos.x=x\n            this.pos.y=y\n            console.log(`${this.name}移动到了x=${this.pos.x},y=${this.pos.y}`)\n        }\n    }\n  \n\n    // 宝可梦\n    class Pokemon extends Item {\n       \n        // 技能\n        skills = []\n        \n        // 放技能\n        useSkill(index){\n            console.log(this.name+'!,快使用'+this.skills[index])\n        }\n        // 学习技能\n        learnSkill(skillName){\n            this.skills.push(skillName)\n        }\n    }\n\n    const pikachu = new Pokemon('皮卡丘')\n    pikachu.moveTo(25,30)\n    pikachu.learnSkill('十万伏特！！')\n    pikachu.learnSkill('快躲开！！')\n    pikachu.useSkill(1)\n</code></pre>\n<p>这样我们就创建好了 Item 类 作为地图上的物体，以及 Pokemon 类 去做宝可梦的动作</p>\n<ul>\n<li>常用调试api</li>\n</ul>\n<pre><code class=\"language-javascript\">    // 等级info \n    console.log('你好')\n    // 等级warning\n    console.warn('你好')\n    // 等级error\n    console.error('你好')\n    // 浏览器断点\n    debugger;\n</code></pre>\n<ul>\n<li>隐式转换<br>\n有趣的jacascript\n比如 + - 这些运算符，会对变量进行隐式转换\n常见number+string的转换是调用对象的toString方法\n或者-的把变量强制转换number类型</li>\n</ul>\n<pre><code class=\"language-javascript\">    console.log(1+'1') // '11'\n    console.log(1-'1') // 0\n    console.log(1-[]) // 1\n    console.log(1+[]) // '1'\n    console.log(1+{}) // '1[object Object]'\n</code></pre>\n<ul>\n<li>变量提升和作用域<br>\n了解就行<br>\nvar 和 funcion 的变量会提升至作用域顶端\n而 const let 和 箭头函数 不会</li>\n</ul>\n<pre><code class=\"language-javascript\">    // var 提升\n    console.log(a) // undefined\n    var a = 1\n    console.log(a) // 1\n    // function 提升\n    fn1()\n\n    function fn1(){\n        console.log(1)\n    }\n\n    fn2() // 代码执行到这里就会报错 fn2 is not defined\n\n    const fn2 = () => console.log(2)\n</code></pre>\n<ul>\n<li>ajax 请求<br>\n我们用封装好的axios库，并不需要自己手写ajax请求，了解就好<br>\n原生请求有  XMLHttpRequest 和 fetch 可以去 mdn 查</li>\n<li>es6 常用api<br>\n博客：https://es6.ruanyifeng.com/<br>\n文档：https://developer.mozilla.org/zh-CN/</li>\n<li>异步 宏任务微任务 和事件循环<br>\n这也不用学，了解就好<br>\njs容器是v8引擎，v8引擎是单线程，当他遇到开销较大的代码是就会卡住，导致后续支持渲染的函数滞后运行，所以js提供了一个事件循环实现异步<br>\n常见的异步函数有定时器 setTimeout/setInterval，promise，ajax\n异步任务会在主线程空闲时通过事件循环被调用<br>\n其中 setTimeout/setInterval 是宏任务，放进宏任务队列<br>\n其中 promise 是微任务 放进微任务队列<br>\n微任务的优先级比宏任务高<br>\n常用<code>Promise.resolve().then()</code> 创建一个微任务<br>\n也可以通过<code>queueMicrotask</code> 创建一个微任务</li>\n</ul>\n<pre><code class=\"language-javascript\">    setTimeout(()=>console.log(1),0)\n    Promise.resolve().then(()=>console.log(2))\n    console.log(3)\n    // 3会比12先输出，因为12是异步任务\n    // 2会比1先输出，因为Promise创建的是微任务\n</code></pre>\n<ul>\n<li>Promise\nPromise的功能</li>\n</ul>\n<ol>\n<li>封装了一组状态 pedding/fulfilled/rejected</li>\n<li>内部状态，只有创建promise时传入的function的resolve和reject可以修改</li>\n<li>状态一旦修改就锁定了</li>\n<li>可以通过.then .catch 函数执行不同状态的回调</li>\n</ol>\n<p>通常我们用promise是一个未知异步结果，对他的成功/失败状态执行不同的function\najax 是最常见的异步</p>\n<pre><code class=\"language-javascript\">    // img 的 onload 和 onerror 为例\n    function reqSrc(img){\n        return new Promise((resolve,reject)=>{\n            img.src='http://heihei.com/pics/wuwuwu.jpg'\n            img.onload=resolve\n            img.onerror=reject\n        })\n    }\n\n    const imgReqSreResult=reqSrc(img)\n    imgReqSreResult.then(()=>{\n        console.log('成功了')\n    }).catch(()=>{\n        console.log('失败了')\n    })\n</code></pre>\n<ul>\n<li>async/await\nasync/await 原理是生成器函数的语法糖，生成器函数可以在下一次迭代前停止执行<br>\nasync声明的是一个异步函数，他将返回一个Promise，在async函数中使用await 修饰的异步函数，会在其执行结束之前阻塞后续代码执行(虽然说阻塞，但实际上还是被事件循环调用，不会影响主线程)</li>\n</ul>\n<pre><code class=\"language-javascript\">    async function InitImg(){\n        function reqSrc(img){\n            return new Promise((resolve,reject)=>{\n                img.src='http://heihei.com/pics/wuwuwu.jpg'\n                img.onload=resolve\n                img.onerror=reject\n            })\n        }\n\n        const imgReqSreResult = await reqSrc(img)\n\n        console.log(1) // 虽然 reqSrc是个异步任务，log函数还是会在其执行后打印，因为这是在async函数中 reqSrc这个promise被await了\n    }\n</code></pre>\n<ul>\n<li>try/catch<br>\n异常捕获</li>\n</ul>\n<pre><code class=\"language-javascript\">    var obj={\n        skillList:['十万伏特']\n    }\n    try{\n        console.log(obj.skillList[1])\n    }catch(e){\n        console.log(e)\n    }\n</code></pre>\n<ul>\n<li>模块化<br>\n2种风格 commonjs 和 esmodule<br>\ncommonjs 通常用在 nodejs 他的语法</li>\n</ul>\n<pre><code class=\"language-javascript\">    // main.js\n    const moduleA = require('./a.js')\n    ...\n    // a.js\n    module.exports={\n        name:'moduleA'\n    }\n</code></pre>\n<p>esmodule 用在浏览器</p>\n<pre><code class=\"language-javascript\">    // main.js\n    import moduleA from './a.js'\n    ...\n\n    // a.js\n    export default {\n        name:'moduleA'\n    }\n</code></pre>\n<p>html - 并不重要,百度看文档就行</p>\n<ul>\n<li>标签</li>\n<li>dom api</li>\n</ul>\n<p>css - 看文档就行</p>\n<ul>\n<li>样式表</li>\n<li>flex 布局<br>\n移动端常用布局<br>\n博客：http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</li>\n</ul>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}