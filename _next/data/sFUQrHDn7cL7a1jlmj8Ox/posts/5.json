{"pageProps":{"postData":{"id":"5","title":"[PARCEL]还是很快快，代理跨域parcel-proxy-server","tags":["Parcel"],"date":"2020-04-21","image":"/boboan.github.io/posts/5/1.png","abstract":"今天我在运行 echarts 实例代码时，请求数据时发现跨域了，想到 PARCEL 启动时本身就有一个本地的 server 服务，那能不能在这个服务里代理一下我的 api 请求呢？ 去 github 上 parcel 的 issue 里一搜，还真有大神写好了的","contentHtml":"<p>今天我在运行echarts实例代码时，请求数据时发现跨域了，想到PARCEL启动时本身就有一个本地的server服务，那能不能在这个服务里代理一下我的api请求呢？\n去github上parcel的issue里一搜，还真有大神写好了的\n<img src=\"/boboan.github.io/posts/5/1.png\">\n瞟了眼代码好像是用express+http-proxy-middleware+parcel的api实现的，不研究，研究就不快快了，别人写好用就行了</p>\n<h4>测试时遇到了跨域问题</h4>\n<p>跑一个echarts 1千w点的实例代码时，发现数据资源跨域了，请求不到\n<img src=\"/boboan.github.io/posts/5/2.png\">\n<img src=\"/boboan.github.io/posts/5/3.png\"></p>\n<p>试试刚才找的parcel-proxy-server\n在npm简介里有他的例子，parcel-proxy-server:https://www.npmjs.com/package/parcel-proxy-server</p>\n<h4>proxy.js</h4>\n<pre><code class=\"language-javascript\">const ParcelProxyServer = require('parcel-proxy-server');\n\n// configure the proxy server\n\nconst server = new ParcelProxyServer({\n\n  entryPoint: './path/to/my/entry/point',\n\n  parcelOptions: {\n\n    // provide parcel options here\n\n    // these are directly passed into the\n\n    // parcel bundler\n\n    //\n\n    // More info on supported options are documented at\n\n    // https://parceljs.org/api\n\n    https: true\n\n  },\n\n  proxies: {\n\n    // add proxies here\n\n    '/api': {\n\n      target: 'https://example.com/api'\n\n    }\n\n  }\n\n});\n\n// the underlying parcel bundler is exposed on the server\n\n// and can be used if needed\n\nserver.bundler.on('buildEnd', () => {\n\n  console.log('Build completed!');\n\n});\n\n// start up the server\n\nserver.listen(8080, () => {\n\n  console.log('Parcel proxy server has started');\n\n});\n</code></pre>\n<p>官网没有很详细的使用方法，不过没关系，稍微读一下代码。</p>\n<h5>1.怎么运行？参数配置？</h5>\n<p>看最后<code>server.listen</code>,哦很眼熟，这个JS起了一个httpserver，那这个JS尝试一下用node运行一下这个js <code>node ./proxy.js  </code>\n起来了，但是为什么能这么启动PARCEL打包呢？\n我又去到parcel官网文档中找到了，parcel提供了API用js启动：<a href=\"https://parceljs.org/api.html\">https://parceljs.org/api.html</a>\n稍微ctrl点一下ParcelProxyServer找下代码，可以发现<strong>entryPoint</strong>，<strong>parcelOptions</strong>，这两个参数，全部都是用于parcel的打包配置，所以都去PARCEL官网找就没问题。</p>\n<h5>2.Proxy？</h5>\n<p>再点一下ParcelProxyServer代码，看到他的引用</p>\n<pre><code class=\"language-javascript\">const fs = require('fs');\nconst https = require('https');\nconst express = require('express');\nconst Bundler = require('parcel-bundler');\nconst proxyMiddleware = require('http-proxy-middleware');\nconst opn = require('opn');\nconst selfSigned = require('selfsigned');\n</code></pre>\n<p>大大的express和 proxy-middleware，那猜测他是express起的服务，使用http-proxy-middleware中间件实现的请求代理，然后用parcel的api进行打包\n那简单了，去翻<strong>http-proxy-middleware</strong>的文档！<a href=\"https://www.npmjs.com/package/http-proxy-middleware\">https://www.npmjs.com/package/http-proxy-middleware</a></p>\n<p>最后我的proxy代码是这样的，请求/api路径会被中间件拦截，后台去请求https://www.echartsjs.com</p>\n<pre><code class=\"language-javascript\">const ParcelProxyServer = require('parcel-proxy-server');\n\n// configure the proxy server\nconst server = new ParcelProxyServer({\n  entryPoint: './index.html',\n  parcelOptions: {},\n  proxies: {\n    // add proxies here\n    '/api': {\n      target: 'https://www.echartsjs.com',\n      changeOrigin: true,\n      pathRewrite: {\n        '/api': '/examples'\n      }\n    }\n  }\n});\n\n// the underlying parcel bundler is exposed on the server\n// and can be used if needed\nserver.bundler.on('buildEnd', () => {\n  console.log('Build completed!');\n});\n\n// start up the server\nserver.listen(8080, () => {\n  console.log('Parcel proxy server has started');\n});\n</code></pre>\n<p>又可以开心的测试了\n<img src=\"/boboan.github.io/posts/5/4.png\"></p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}