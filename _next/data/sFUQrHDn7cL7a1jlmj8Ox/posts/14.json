{"pageProps":{"postData":{"id":"14","title":"nodejs手写一个httpserver(一、app/router对象)","tags":["nodejs"],"date":"2020-11-24","image":"/boboan.github.io/posts/14/1.png","abstract":"对比原生的node http模块，express这些API非常好用了，并且use方法，可以把功能代码拆分出来，比如**body-parser** **router** 都是拆成中间件的形式，完成自己的功能的 试着手写一个server实现这些功能，开发一个能用一些实用的API的server，而不是原生NodeAPI","contentHtml":"<p>先参考（抄袭）一下express的api\n<code>app.use(...);</code>\n<code>router.get(url,...)</code>\n<code>router.post(url,...)</code>\n对比原生的node http模块，express这些API非常好用了，并且use方法，可以把功能代码拆分出来，比如<strong>body-parser</strong> <strong>router</strong> 都是拆成中间件的形式，完成自己的功能的\n试着手写一个server实现这些功能，开发一个能用一些实用的API的server，而不是原生NodeAPI\n<img src=\"/boboan.github.io/posts/14/1.png\"></p>\n<h2>app</h2>\n<p>app是传入HTTP.createServer的handeler，那它肯定是这样一个函数</p>\n<pre><code class=\"language-javascript\">const app = (req, res) => {\n   ...\n}\n</code></pre>\n<p>用于执行use注册的中间件，把url分发给router路由（其实这是router该干的事，app只处理use的中间件）</p>\n<h3>实现app.use</h3>\n<p>用中间件的时候，中间件中都有3个参数，req,res,next，前两个简单，从app作用域就能拿到，那么next()调用呢，next调用时，也有3个参数，reqresnext，其中next是下一环节的中间件。\n想了半天，给注册的中间件数组们一个排序，创建了一个next方法按序调用。。。（应该不太对，不过实现了）</p>\n<pre><code class=\"language-javascript\">const app = (req, res) => {\n    // json api\n    res.json = json\n    console.log('start', req.method, req.url, req.query)\n    // 反着给他们帮定next参数\n    function next(index) {\n        console.log('next' + index, req.url, req.query)\n        app.actions[index].call(this, req, res, next.bind(this, index + 1))\n    }\n\n    app.actions[0](req, res, next.bind(this, 1));\n}\napp.actions = []\n\n// 实现注册中间件\napp.use = (handler) => {\n    app.actions.push(handler)\n}\nmodule.exports = app\n\n// json\nfunction json(object) {\n    this.writeHeader(200, { 'Content-Type': 'application/json;charset=UTF-8' })\n    this.write(JSON.stringify(object))\n    this.end()\n}\n</code></pre>\n<h2>router</h2>\n<p>router的功能是用来分发url给 router.get 或 router.post 注册的handler\n那简单，用if判断一下就好了</p>\n<pre><code class=\"language-javascript\">const router = (req, res, next) => {\n    const { method, url } = req\n    if (method === 'GET') {\n        router.getRoutes[url](req, res, next)\n    } else if (method === 'POST') {\n        router.postRoutes[url](req, res, next)\n    }\n}\nrouter.getRoutes = {}\nrouter.postRoutes = {}\nrouter.get = (path, handler) => {\n    router.getRoutes[path] = handler\n}\nrouter.post = (path, handler) => {\n    router.postRoutes[path] = handler\n}\n\nmodule.exports = router\n</code></pre>\n<h2>中间件</h2>\n<p>写好了app.use,就可以疯狂的以中间件的形式写server的功能了</p>\n<h3>queryString</h3>\n<p>原始的message.url 是带着参数的，要在这个环节给拆出来，用正则表达式替换就可以了</p>\n<pre><code class=\"language-javascript\">let { REG_URL } = require('./CONST') ///(?!=\\?)(\\/.+)\\?(.+)/\n\n// 处理querystring中的参数\n\nmodule.exports = function (req, res, next) {\n    const url = req.url.replace(REG_URL, '$1')\n    const querys = req.url.replace(REG_URL, '$2').split('&#x26;')\n    const query = {}\n    querys.forEach(item => {\n        const [key, value] = item.split('=')\n        query[key] = value\n    })\n    req.url = url\n    req.query = query\n    next()\n}\n</code></pre>\n<h3>body-parser</h3>\n<p>body-parser太难写了，看了半天api文档也没明白咋取，知道的朋友给我留言，谢谢你们了。\n好在写了app.use,直接use第三方的body-parser模块就可以实现了。\n<img src=\"/boboan.github.io/posts/14/2.png\">\n还行，第三方模块可以用，最基本的流程跑通了</p>\n<p>over 没处理报错</p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}