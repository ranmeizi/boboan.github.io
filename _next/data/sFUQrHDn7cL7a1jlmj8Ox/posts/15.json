{"pageProps":{"postData":{"id":"15","title":"nodejs手写一个httpserver(二、middleware：body-parser,errorhandler)","tags":["nodejs"],"date":"2020-12-12","image":"/boboan.github.io/posts/15/1.png","abstract":"当程序没有按照我们给定流程运行时，都要判断一下并返回异常错误码，但又不希望每执行一处逻辑都要判断一次。这时候就可以用到```try catch```  和``` Error ``` 但上次写的server全部都是异步的 try catch 捕获不到其中的错误，所以要把之前写的server改写成一个异步链,所有中间件function和controller function都使用```async``` ```await```调用。","contentHtml":"<h2>异常处理</h2>\n<p>抄袭一下eggjs的error handler做法:https://eggjs.org/zh-cn/tutorials/restful.html#%E7%BB%9F%E4%B8%80%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86\n当程序没有按照我们给定流程运行时，都要判断一下并返回异常错误码，但又不希望每执行一处逻辑都要判断一次。这时候就可以用到<code>try catch</code>  和<code>Error</code>\n但上次写的server全部都是异步的 try catch 捕获不到其中的错误，所以要把之前写的server改写成一个异步链,所有中间件function和controller function都使用<code>async</code> <code>await</code>调用。</p>\n<pre><code class=\"language-javascript\">const app = async (req, res) => {\n    const ctx = { req, res, json }\n    // json api\n    res.json = json\n    console.log('start', req.method, req.url, req.query)\n    // 反着给他们帮定next参数\n    async function next(index) {\n        await app.actions[index].call(this, req, res, next.bind(ctx, index + 1))\n    }\n\n    await app.actions[0](req, res, next.bind(ctx, 1));\n}\napp.actions = []\n\n// 实现注册中间件\napp.use = (handler) => {\n    app.actions.push(handler)\n}\nmodule.exports = app\n\n// json\nfunction json(object) {\n    this.writeHeader(200, { 'Content-Type': 'application/json;charset=UTF-8' })\n    this.write(JSON.stringify(object))\n    this.end()\n}\n</code></pre>\n<p>组成了异步链后，就可以在程序最顶层使用<code>app.use(errorHandler)</code>中间件，包裹一层<code>try catch</code>来捕获内部抛出的异常了</p>\n<pre><code class=\"language-javascript\">module.exports = async function (req, res, next) {\n    try {\n        await next()\n    } catch (e) {\n        res.json({\n            msg: '出错了'\n        })\n    }\n}\n</code></pre>\n<h2>body-parser</h2>\n<p>当server改成异步调用之后，原先express的body-parser也就不适用了，因为express全部是异步回调的，并没有组成async await异步链。我又看了下koa-bodyparser是async但是传参又和我的app不一样- -，传参是(ctx,next)还是不改了，自己写一下只解析json的bodyparser</p>\n<pre><code class=\"language-javascript\">// 处理body中的json参数\nmodule.exports = async function (req, res, next) {\n    try {\n        req.body = await new Promise(resolve => {\n            const chunks = [];\n            req.on('data', buf => {\n                chunks.push(buf);\n            })\n            req.on('end', async () => {\n                let buffer = Buffer.concat(chunks);\n                resolve(JSON.parse(buffer.toString()));\n            })\n        })\n    } catch (e) {\n        console.warn('body-parser error', e)\n    }\n\n    await next()\n}\n</code></pre>\n<p>找到获取body值的方法了，监听<code>data</code>事件，会一点一点吧buffer吐给你，只要拼接玩buffer当他是个接送string转string，就可以了，当然也要把这个中间件写成async方法在这个app中才能用</p>\n<p>真正的body里并不只有json数据，要是全都自己写还是算了把。。。</p>\n<p>抄了一半express一半egg哈哈</p>\n<h2>测试这条路由和errorhandler</h2>\n<pre><code class=\"language-javascript\">router.post('/abc', async (req, res) => {\n    if (req.query.action === 'error') {\n        throw new Error('错了')\n    }\n    console.log('???', req.body)\n    res.json({\n        name: '我我我post',\n        age: 2\n    })\n})\n</code></pre>\n<p>body中的json字符串被解析到req.body中了\n抛出的异常也被catch到了\n<img src=\"/boboan.github.io/posts/15/1.png\">\n<img src=\"/boboan.github.io/posts/15/2.png\"></p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}