{"pageProps":{"postData":{"id":"28","title":"taro3.x 小程序网络图片loader","tags":["taro","webpack","loader"],"date":"2022-09-08","image":"/boboan.github.io/images/tags/webpack.webp","abstract":"小程序和其他环境不一样，打包后的体积真是寸土寸金，图片资源最好是用网络地址，所以写一个loader来上传文件，返回网络地址","contentHtml":"<p>小程序和其他环境不一样，打包后的体积真是寸土寸金，图片资源最好是用网络地址，所以写一个loader来上传文件，返回网络地址</p>\n<h2>url-laoder 或是 postcss-loader</h2>\n<p>taro 用了 url-laoder 或是 postcss-loader  将图片 base64 打到 js 里，虽说又 limit 参数，但我试了试不好用，就算好用，打到本地图片也不是我希望的。\nurl-loader 有一个配置是，超出 limit 上线，可以走 fallback 一个自己的 loader</p>\n<h2>修改 taro 打包配置</h2>\n<p>需要修改一下 taro 的编译配置<br>\nmini.postcss.url</p>\n<pre><code class=\"language-javascript\">      url: {\n        enable: true,\n        config: {\n          limit: 0, // 设定转换尺寸上限\n          url: ''\n        },\n      },\n</code></pre>\n<p>用 webpackChain 修改 image rule 的 loader 参数<br>\n再 url-loader 添加 fallback 让他走自己写的 loader</p>\n<pre><code class=\"language-javascript\">webpackChain(chain) {\n      chain.plugin('WxssImportPlugin').use(WxssImportPlugin)\n      chain.module\n        .rule('image')\n        .use('urlLoader')\n        .tap(options => {\n          options.fallback = path.resolve(__dirname, '../build/ImageUploadLoader/index.js')\n          return options\n        })\n\n      // console.log(chain.resolve.plugins)\n    }\n</code></pre>\n<h2>loader 部分的代码</h2>\n<p>每次构建都会走 loader 的代码，我不希望每次都上传图片，所以可以用 md5 再本地做一个上传结果的缓存</p>\n<pre><code class=\"language-javascript\">// index.js\nconst buf2Url = require('./utils/buf2Url')\n\n/**\n * 因为小程序分包大小问题，我们把所有本地图片上传到fs上，然后用返回网络地址 \n * \n * 存储一个md5 作为缓存，在memo中的地址，直接使用，不存在的上传fs\n */\n\nmodule.exports = async function (value) {\n  const callback = this.async();\n\n  const raw = this._module.rawRequest.split('/')\n  const filename = raw[raw.length - 1]\n\n  const url = await buf2Url(value, filename)\n\n  callback(null, moduleStr(url))\n}\n\nfunction moduleStr(str) {\n  return `module.exports='${str}'`\n}\n</code></pre>\n<p>url-loader 会传入 buffer，拿着 buffer 上传文件，拿到 url 地址</p>\n<pre><code class=\"language-javascript\">// utils/buf2url.js\nconst md5 = require('md5')\nconst axios = require('axios')\nconst fs = require('fs')\nconst path = require('path')\nconst FormData = require('form-data')\n\nconst UploadPath = # 上传地址\n\nmodule.exports = function (buf, filename) {\n  // 获取md5值\n  const key = md5(buf)\n\n  console.log('filename', filename)\n\n  let memo\n  try {\n    memo = JSON.parse(fs.readFileSync(path.resolve(__dirname, '../md5memo.json')))\n  } catch (e) {\n    memo = {}\n  }\n\n  return new Promise(resolve => {\n    // 是否在memo中存在\n    if (key in memo) {\n      resolve(memo[key].fullPath)\n    } else {\n      // 上传\n      try {\n        let form = new FormData()\n        form.append('file', buf, { filename })\n        axios.post(UploadPath, form, {\n          headers: {\n            'Content-Type': 'multipart/form-data',\n            ...form.getHeaders()\n          }\n        }).then(res => {\n          try {\n            memo = JSON.parse(fs.readFileSync(path.resolve(__dirname, '../md5memo.json')))\n          } catch (e) {\n            memo = {}\n          }\n          // 存json\n          memo[key] = {\n            # 取网络地址\n            fullPath: res.data.data.fullPath,\n            filename\n          }\n          fs.writeFileSync(path.resolve(__dirname, '../md5memo.json'), JSON.stringify(memo, null, 2))\n          resolve(res.data.data.fullPath)\n        })\n      } catch (e) {\n        console.log('出错了？')\n        resolve()\n      }\n    }\n  })\n}\n</code></pre>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}