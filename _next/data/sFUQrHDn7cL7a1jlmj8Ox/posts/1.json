{"pageProps":{"postData":{"id":"1","title":"前端通过Chrome插件跨域请求","tags":["extension"],"date":"2020-01-22","image":"/boboan.github.io/posts/1/1.png","abstract":"我们肯定学过，通过 jsonp 实现跨域请求，或是后台通过 cors 实现跨域请求，这次开拓一个新思路，使用 chrome 插件绕过浏览器同源策略...","contentHtml":"<p>我们肯定学过，通过jsonp实现跨域请求，或是后台通过cors实现跨域请求，这次开拓一个新思路，使用chrome插件绕过浏览器同源策略</p>\n<p>参考文档：<a href=\"http://chrome.cenchy.com/\">http://chrome.cenchy.com/</a>    <a href=\"https://developer.chrome.com/extensions\">https://developer.chrome.com/extensions</a></p>\n<p>这是我后面做的一个ajax劫持跨域插件：https://www.jianshu.com/p/417ffc9bf1a2</p>\n<h4>DEMO效果图</h4>\n<p><img src=\"/boboan.github.io/posts/1/1.png\"></p>\n<h4>原理图</h4>\n<p><img src=\"/boboan.github.io/posts/1/2.png\"></p>\n<p>background.html：background页是<a href=\"chrome://extensions/\">chrome://extensions/</a>打开的，没有域，所以使用background请求不会被浏览器同源策略影响</p>\n<p>content_script:通过谷歌插件注入到页面中的JS，使用他创建 <strong>EventDom</strong> 用于接收提交按钮的请求发送给background页</p>\n<p>EventDom:因为content_script是无法直接与页面中的JS通信的，但是content_script可以操作页面中的dom，我们可以使用content_script创建一个EventDom.帮我们传递 <strong>事件</strong> 与 <strong>数据</strong></p>\n<h4>1. 创建一个Chrome插件项目</h4>\n<p><strong>创建manifest.json</strong></p>\n<pre><code class=\"language-json\">{\n\t\"manifest_version\": 2,\n\t\"name\": \"One-click Kittens\",\n\t\"description\": \"This extension demonstrates a browser action with kittens.\",\n\t\"version\": \"1.0\",\n\t\"permissions\": [\n\t\t\"http://127.0.0.1/\",\n\t\t\"tabs\"\n\t],\n\t\"browser_action\": {\n\t\t\"default_icon\": \"icon.png\",\n\t\t\"default_popup\": \"popup.html\"\n\t},\n\t\"background\": {\n\t\t\"scripts\": [\n\t\t\t\"background.js\"\n\t\t]\n\t},\n\t\"web_accessible_resources\": [\n\t\t\"/*\"\n\t],\n\t\"content_scripts\": [\n\t\t{\n\t\t\t\"matches\": [\n\t\t\t\t\"http://127.0.0.1/\"\n\t\t\t],\n\t\t\t\"js\": [\n\t\t\t\t\"content_script.js\"\n\t\t\t]\n\t\t}\n\t]\n}\n</code></pre>\n<h4>2.background.js</h4>\n<p>background中通过chrome.runtime中的api，可以实现background和content_script之间的的通信\nbackground使用tabId给对应的content_script发送消息</p>\n<pre><code class=\"language-javascript\">chrome.runtime.onMessage.addListener(function (e, sender) {\n  const { message, data } = e\n  const tabId = sender.tab.id\n  switch (message) {\n    case 'XHR':\n      request_proxy(data, tabId); break\n  }\n})\nfunction request_proxy({ url, method, data }, tabId) {\n  var XHR = new XMLHttpRequest()\n  console.log(tabId)\n  XHR.open(method, url)\n  XHR.setRequestHeader('Content-Type', 'application/json;charset=UTF-8');\n  XHR.send(data)\n  XHR.onreadystatechange = function () {\n    if (XHR.readyState === 4) {\n      chrome.tabs.sendMessage(tabId, {\n        message: 'XHR_response',\n        data: XHR.responseText\n      })\n    }\n  }\n}\n</code></pre>\n<h4>3.content_script</h4>\n<p>使用content_script创建EventDom。这里随便创建了个‘button’，没别的意思，任何标签都可以，只是使用element.dispatchEvent触发自定义事件。\n然后通过触发（dispatchEvent）/响应（addEventListener）EventDom的事件与HTML页进行通信\n并通过chrome的API   发送（chrome.runtime.sendMessage）/接收（chrome.runtime.onMessage.addListener）与background进行通信\ndispatchEvent:<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent\">https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent</a></p>\n<pre><code class=\"language-javascript\">var button = document.createElement('button'); //创建EventDom\nbutton.id = 'chrome_eventBus'\nbutton.addEventListener('request_proxy', function (e) {\n    let { eventData } = e.target.dataset\n    eventData = JSON.parse(eventData)\n    let { url, method, data } = eventData\n    chrome.runtime.sendMessage('jencllhednpfafogdnjmoneilbiifloc', {\n        message: 'XHR',\n        data: {\n            url,\n            method,\n            data\n        }\n    })\n})\ndocument.body.appendChild(button);\nconst e = new Event('content_script_Ready') //触发自定义事件，在content_script注入并添加dom后，通知html页绑定Dom的事件\ndocument.body.dispatchEvent(e)\n\n\nchrome.runtime.onMessage.addListener(function (e, sender, sendResponse) {\n    console.log(e, sender, sendResponse)\n    const { message, data } = e\n    switch (message) {\n        case 'XHR_response':\n            response(data); break\n    }\n})\n\nfunction response(data) {\n    button.dataset['eventData'] = data\n    const e = new Event('response')\n    button.dispatchEvent(e)\n}\n</code></pre>\n<h4>4.Html页</h4>\n<p>html页就是你的项目，在这里你需要在content_script注入完毕后为EventDOM绑定事件。将请求通过EventDom发送给content_script\n例如  登陆请求时dispatch EventDom的request_proxy事件，通过html5的dataset传递数据（也可以通过别的传,例如localstorage，indexdb。。。）</p>\n<pre><code class=\"language-javascript\">let iptUrl = document.getElementById('url')\nlet iptMethod = document.getElementById('method')\nlet iptData = document.getElementById('data')\n\nlet $ChromeEventBus = null //EventDom\n\ndocument.getElementById('req-default').addEventListener('click', () => {\n  let url = iptUrl.value\n  let method = iptMethod.value\n  let data = iptData.value\n\n  let XHR = new XMLHttpRequest()\n  XHR.open(method, url)\n  XHR.send(JSON.stringify(data))\n})\ndocument.getElementById('req-background').addEventListener('click', () => {\n  let url = iptUrl.value\n  let method = iptMethod.value\n  let data = iptData.value\n  let option = {\n    url,\n    method,\n    data\n  }\n  $ChromeEventBus.dataset['eventData'] = JSON.stringify(option)\n  const e = new Event('request_proxy')\n  $ChromeEventBus.dispatchEvent(e)\n})\ndocument.body.addEventListener('content_script_Ready', Init) //当content_script注入完毕，并且创建EventBus后，进行事件的初始化\nfunction Init() {\n  $ChromeEventBus = document.getElementById('chrome_eventBus')\n  $ChromeEventBus.addEventListener('response', function (e) {\n    let { eventData } = e.target.dataset\n    console.log('response', JSON.parse(eventData))\n  })\n}\n\n</code></pre>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}