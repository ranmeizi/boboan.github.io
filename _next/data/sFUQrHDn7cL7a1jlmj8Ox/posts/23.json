{"pageProps":{"postData":{"id":"23","title":"loadscript","tags":["javascript"],"date":"2021-07-23","image":"/boboan.github.io/images/tags/js.jpg","abstract":"loadscript 是使用js去请求一个 script 到文档里，这样不会在首次加载时去下载和执行script，就为浏览器减少了首次渲染的工作量","contentHtml":"<p>loadscript 是使用js去请求一个 script 到文档里，这样不会在首次加载时去下载和执行script，就为浏览器减少了首次渲染的工作量</p>\n<p>打包后代码很可能是长这样，里面有好多 module，好多变量，好多 function，最后有一个 render 函数，调用 vue/react 的渲染函数去渲染 element</p>\n<pre><code class=\"language-javascript\">(function () {\n  /* \n  ... const module= ...\n  ... const data=...\n  ... function action(){\n      ...\n    }\n  一大串代码。有多长呢？\n  */\n\n  function render() {\n    // render\n    ReactDOM.render(a, document.getElementById('root'))\n  }\n\n  render()\n})()\n</code></pre>\n<h2>浏览器对于html文档解析的大概顺序</h2>\n<p>看看<a href=\"https://www.zhihu.com/question/30218438?sort=created\">知乎大佬回答</a>\n取几个关键点来看<br>\n浏览器是从上到下从左到右解析 html 文档的\nscript 中可能会有 dom 操作，浏览器在解析script标签后就阻塞 dom 树的构建</p>\n<p>思考一下我把支持我渲染的代码放到 RenderScript 里，整个页面就是个 div 容器和 render script，这样就可以做到最快的渲染出页面。反过来说就是把代码中和渲染无关，甚至和首屏无关的代码，都可以抛弃，这样首屏渲染就不会被无关的js阻塞</p>\n<h2>使用js创建标签请求script</h2>\n<pre><code class=\"language-javascript\">const script = document.createElement('script')\nscript.src = src\ndocument.head.appendChild(script)\n</code></pre>\n<h2>Promise</h2>\n<blockquote>\n<p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p>\n</blockquote>\n<p>插入 script 的操作可以看作<strong>执行了一个动作</strong>(扔给浏览器一个 script 标签让他加载)，但是并不是立马生效，浏览器要去下载，下载也可能因为网络失败，那他就是一个标准的<strong>未来才会结束的事件</strong>，并且有2个状态：成功：失败\n状态理清了，在不同状态下执行不同的代码，这就是 promise 的好处。比如我请求 echarts 的 js，我请求成功后，我就可以调用<code>echarts.init</code>开始画图了；如果失败了，我应该显示 error 画面，提醒用户，加载失败了，或者重试\n来试试把 loadscript 封装成 promise</p>\n<pre><code class=\"language-javascript\">function LoadScript(src) {\n\treturn new Promise((resolve, reject) => {\n\t\tconst script = document.createElement('script')\n\t\tscript.src = src\n\t\tscript.onload = resolve\n\t\tscript.onerror = reject\n\t\tdocument.head.appendChild(script)\n\t})\n}\n</code></pre>\n<h2>单例模式</h2>\n<p>相同的 script 不用重复请求，而是取上一次的结果就好了。理清了 promise ，那把这个请求 script 的 promise 操作按照src存起来就好了，我下一次按照 src 想调用<code>loadScript</code>函数，我就可以拿到上次的请求结果啦\n不过注意的是，上次 loadScript 如果失败了，那这个 promise 就永远是 rejected 状态了，要想重试的话，只能删除这个值，重新创建 script，所以我们要写一个<code>delete</code> 函数去清除存储的值</p>\n<pre><code class=\"language-javascript\">const LoadScript = (function () {\n\tlet instances = {}\n\treturn function (src) {\n\t\tif (!instances[src]) {\n\t\t\tinstances[src] = new Promise((resolve, reject) => {\n\t\t\t\tconst script = document.createElement('script')\n\t\t\t\tscript.src = src\n\t\t\t\tscript.onload = resolve\n\t\t\t\tscript.onerror = reject\n\t\t\t\tdocument.head.appendChild(script)\n\t\t\t})\n\t\t\t// 提供一个删除instace的接口\n\t\t\tinstances[src].deleteInstance = function () {\n\t\t\t\tdelete instances[src]\n\t\t\t}\n\t\t}\n\t\treturn instances[src]\n\t}\n})()\n</code></pre>\n<p>这样就改造好啦，不论多少次调用loadscript，实际上这个动作只执行1次，就实现多次<code>loadscript</code>取上一次的结果了</p>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}