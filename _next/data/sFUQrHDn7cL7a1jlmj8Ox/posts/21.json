{"pageProps":{"postData":{"id":"21","title":"[extention] extention 项目构建","tags":["extention"],"date":"2021-06-10","image":"/boboan.github.io/posts/21/1.png","abstract":"是这样的，最近想要开发一个浏览器拓展的应用，刚开始就给我恶心到了，每天都用着第三方模块和 import export 切分文件的我面对一个个独立的js竟无从下手，那么就用webpack来构建一个模块化的 extention 项目吧~","contentHtml":"<p>是这样的，最近想要开发一个浏览器拓展的应用，刚开始就给我恶心到了，每天都用着第三方模块和 import export 切分文件的我面对一个个独立的js竟无从下手，那么就用webpack来构建一个模块化的 extention 项目吧~</p>\n<p>项目地址：https://gitee.com/boboanzuiniubi/ext-xhr-proxy\n这个是个xhr劫持的拓展工具，我会在做完功能之后，把项目模板拆出来~</p>\n<h2>先分析一下要做什么吧</h2>\n<h2>manifest.json</h2>\n<pre><code class=\"language-json\">{\n\t\"manifest_version\": 2,\n\t\"name\": \"zcr\",\n\t\"description\": \"ceshi\",\n\t\"version\": \"1.0\",\n\t\"content_scripts\": [{ \"matches\": [\"&#x3C;all_urls>\"], \"css\": [], \"js\": [\"./content_scripts/inject_xhr.js\"] }]\n}\n</code></pre>\n<p>manifest.json 是位于项目根目录下的拓展应用的清单文件，这里面是拓展应用的描述，和 content_scripts/page/icon 等等资源的地址。大多属性是静态的，<strong>资源地址</strong> 是整个构建流程需要处理的，要做的是将构建后的资源目录，写入 manifest.json ，亦或者是按照 manifest 上写的路径去构建资源。</p>\n<h2>load scripts</h2>\n<p>拓展中的 <code>content_script</code> 和 <code>inject_script</code> 都是需要打包起来的 js 文件，各种单页面 page 也需要打包一个入口文件，那我们就需要写一段 js 去按路径读取这些 js 入口文件，并且要将output的文件地址写入 manifest</p>\n<h2>load pages</h2>\n<p>拓展(extention)中是有一些页面的，比如 popup page / background page / devtools page 都是一个html，我们可以用 <code>html-webpack-plugin</code> 和三大框架构建一个单页面应用来快速开发</p>\n<h2>目录结构与构建流程</h2>\n<p><img src=\"/boboan.github.io/posts/21/1.png\"></p>\n<h2>细化</h2>\n<h2>eslint</h2>\n<p>(todo 但又不完全todo) 在纠结要不要引，因为项目不是很大，不是很关键</p>\n<h2>friendly-errors-webpack-plugin</h2>\n<p><code>friendly-errors-webpack-plugin</code>用来输出webpackl的报错真是简单又好用，省得你去研究怎么输出异常。</p>\n<h2>plugin</h2>\n<p>我这里用的 plugin 是为了在每个模块构建完成时，记录一下需要写入 manifest 的 output 地址的\n找一个合适的钩子获取 output 的地址\n<img src=\"/boboan.github.io/posts/21/2.png\"></p>\n<p>比如传入一个记事本对象,并在构建结束后重写manifest.json</p>\n<pre><code class=\"language-javascript\">const manifest_content_scripts = {\n  matches: ['&#x3C;all_urls>'],\n  css: [],\n  js: []\n}\nconfig.plugins.push(new ContentScriptPlugin(manifest_content_scripts))\n\nwebpack(config, (err, stats) => {\n  if (err || stats.hasErrors()) {\n\n  } else {\n    // 重写manifest\n    fs.writeFileSync(path.resolve(__dirname, '../output/manifest.json'), JSON.stringify({\n      ...manifest,\n      web_accessible_resources: mainfest_web_accessible_resources,\n      content_scripts: [manifest_content_scripts]\n    }))\n  }\n});\n...\n</code></pre>\n<pre><code class=\"language-javascript\">// 这个plugin在构建模块时，记录一条需要注入的content_script\n\nconst isContentJs = (name) => /content_scripts\\/.+\\.js$/.test(name)\nconst isContentCss = (name) => /content_scripts\\/.+\\.css$/.test(name)\n\nmodule.exports = class ContentScriptPlugin {\n  constructor(manifest_content_script) {\n    this.manifest_content_script = manifest_content_script\n  }\n  apply(compiler) {\n    compiler.hooks.assetEmitted.tap(\n      'ContentScriptPlugin',\n      (file, { content, source, outputPath, compilation, targetPath }) => {\n        if (isContentJs(file)) {\n          this.manifest_content_script.js.push(file)\n        } else if (isContentCss(file)) {\n          this.manifest_content_script.css.push(file)\n        }\n      }\n    )\n  }\n}\n</code></pre>\n<h2>react</h2>\n<p>用 react 加其周边的组件库 可以很快速的开发 html 页面，需要<code>babel-loader</code>和<code>html-webpack-plugin</code>去执行jsx语法转换和创建页面。</p>\n<p>配置 babel</p>\n<pre><code class=\"language-json\">// babel.config.json\n{\n  \"presets\": [\n    \"@babel/env\",\n    \"@babel/preset-react\"\n  ]\n}\n</code></pre>\n<p>添加 rules</p>\n<pre><code class=\"language-javascript\">// rules 只处理页面部分的js就可以了，可以加载ext的浏览器并没有兼容性问题\nrules: [{\n      test: /\\.jsx?$/,\n      loader: \"babel-loader\",\n      include: [src('./popup')]\n    },\n    ...\n]\n</code></pre>\n<p>打包入口</p>\n<pre><code class=\"language-javascript\">entry: {\n    ...content_scripts,\n    ...inject_scripts,\n    background: src('./background.js'),\n    popup: src('./popup/index.js')\n},\n</code></pre>\n<p>配置 html plugin</p>\n<pre><code class=\"language-javascript\">plugins: [\n    new HtmlWebpackPlugin({\n      filename: 'popup.html',\n      template: src('./popup/index.html'),\n      chunks: ['popup']\n    }),\n   ...\n  ],\n</code></pre>\n<h2>shelljs</h2>\n<p>用 node 的 file system 处理文件会有各个node版本fs api的兼容性问题，太烦了，用<code>shelljs</code>兼容性问题会少点</p>\n<h2>file-loader</h2>\n<p>拓展应用中的资源文件会有 icon img 这种 图片资源，统一就用<code>file-loader</code> 去放到一个img目录下好了，在manifest中就按照命名引用img目录下的资源</p>\n<pre><code class=\"language-javascript\">rules: [\n    ...   \n   ,{\n      test: /\\.(png|jpe?g|gif)$/i,\n      use: [\n        {\n          loader: 'file-loader',\n          options: {\n            name: 'img/[name].[ext]'\n          }\n        }\n      ]\n    }]\n</code></pre>\n"},"allTags":["nextjs","remark","typescript","taro","webpack","loader","小程序插件","javascript","react","extention","github page","screeps","nodejs","闲的","canvas","promise","vue","Parcel","eggjs","extension"]},"__N_SSG":true}